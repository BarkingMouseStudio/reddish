// Generated by CoffeeScript 1.3.3
(function() {
  var RedisClient, available_commands, check_commands, del_commands, edit_commands, input_commands, key_regex, modify_commands, output_commands, proxies, redis, reply_types, url, val_commands, _ref;

  url = require('url');

  key_regex = /^[a-f0-9]{40}$/;

  proxies = require('../common').proxies;

  _ref = require('./maps'), reply_types = _ref.reply_types, val_commands = _ref.val_commands, del_commands = _ref.del_commands, edit_commands = _ref.edit_commands, modify_commands = _ref.modify_commands, available_commands = _ref.available_commands, input_commands = _ref.input_commands, output_commands = _ref.output_commands, check_commands = _ref.check_commands;

  redis = require('redis');

  RedisClient = redis.RedisClient;

  exports.formatValue = function(value) {
    if (!value) {
      return '(nil)';
    }
    try {
      value = JSON.stringify(JSON.parse(value), null, 2);
    } catch (_error) {}
    if (value != null) {
      return value.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    } else {
      return '(nil)';
    }
  };

  exports.createClient = function(connection, is_monitor) {
    var hostname, instance, key, max_attempts, name, port, proxy, proxy_key, type, _ref1;
    max_attempts = 3;
    type = connection.type, key = connection.key, name = connection.name;
    if (type === 'url') {
      _ref1 = url.parse(name), hostname = _ref1.hostname, port = _ref1.port;
      if (!port) {
        port = 6379;
      }
      if (!hostname) {
        throw new Error('Invalid connection');
        return;
      }
      instance = redis.createClient(port, hostname, {
        max_attempts: max_attempts
      });
    } else {
      if (!key_regex.test(key)) {
        throw new Error('Invalid connection key');
        return;
      }
      proxy_key = !is_monitor ? "" + key + ":STANDARD" : "" + key + ":MONITOR";
      proxy = proxies.get(proxy_key);
      if (!proxy) {
        throw new Error('Proxy not found');
        return;
      }
      instance = new RedisClient(proxy, {
        max_attempts: max_attempts
      });
      instance.is_proxy = true;
      instance.on_connect();
    }
    return instance;
  };

  exports.endClient = function(instance, connection) {
    if (!(instance && instance.connected)) {
      return;
    }
    if (!instance.is_proxy) {
      return instance.quit();
    } else {
      instance.end();
      instance.stream.on('error', function(err) {});
      if (connection.type === 'name' && connection.key) {
        return proxies.del(connection.key);
      }
    }
  };

  exports.handleKey = function(instance, key, callback) {
    return instance.type(key, function(err, type) {
      if (err) {
        callback(err);
        return;
      }
      return instance.ttl(key, function(err, ttl) {
        var del_cmd_args, del_cmd_name, del_cmd_str, val_cmd_args, val_cmd_name, val_cmd_str;
        if (err) {
          callback(err);
          return;
        }
        val_cmd_name = val_commands[type];
        del_cmd_name = del_commands['key'];
        switch (type) {
          case 'zset':
            val_cmd_args = [key, 0, -1, 'WITHSCORES'];
            break;
          case 'list':
            val_cmd_args = [key, 0, -1];
            break;
          default:
            val_cmd_args = [key];
        }
        del_cmd_args = [key];
        val_cmd_str = "" + val_cmd_name + " " + (val_cmd_args.join(' '));
        del_cmd_str = "" + del_cmd_name + " " + (del_cmd_args.join(' '));
        key = {
          id: key,
          type: type,
          ttl: ttl,
          val_cmd_name: val_cmd_name,
          val_cmd_args: val_cmd_args,
          val_cmd_str: val_cmd_str,
          del_cmd_name: del_cmd_name,
          del_cmd_args: del_cmd_args,
          del_cmd_str: del_cmd_str
        };
        return callback(null, key);
      });
    });
  };

}).call(this);
