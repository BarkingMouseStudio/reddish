// Generated by CoffeeScript 1.3.3
(function() {
  var Client, available_commands, check_commands, command_rate_limit, connection_rate_limit, createClient, del_commands, edit_commands, endClient, formatValue, handleKey, input_commands, keys_limit, modify_key_commands, modify_val_commands, monitor_queue_limit, monitor_rate_limit, output_commands, reply_types, val_commands, vals_limit, _, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('underscore');

  _ref = require('./maps'), reply_types = _ref.reply_types, val_commands = _ref.val_commands, del_commands = _ref.del_commands, edit_commands = _ref.edit_commands, modify_key_commands = _ref.modify_key_commands, modify_val_commands = _ref.modify_val_commands, available_commands = _ref.available_commands, input_commands = _ref.input_commands, output_commands = _ref.output_commands, check_commands = _ref.check_commands;

  _ref1 = require('./utils'), endClient = _ref1.endClient, formatValue = _ref1.formatValue, createClient = _ref1.createClient, handleKey = _ref1.handleKey;

  keys_limit = 10000;

  vals_limit = 10000;

  monitor_queue_limit = 10000;

  connection_rate_limit = 1000;

  command_rate_limit = 250;

  monitor_rate_limit = 250;

  module.exports = Client = (function() {

    function Client(socket) {
      var _this = this;
      this.socket = socket;
      _.bindAll(this);
      this.last_keys_pattern = '*';
      this.monitor_events_queue = [];
      this.socket.on('reddish:connect', this.handle_connect);
      this.socket.on('reddish:disconnect', this.handle_disconnect);
      this.socket.on('reddish:command', this.send_command);
      this.socket.on('disconnect', function(err, callback) {
        return _this.handle_disconnect(callback);
      });
    }

    Client.prototype.send_command = _.throttle(function(command, args, callback) {
      var err, key, send_command,
        _this = this;
      if (!command) {
        if (callback) {
          callback(err = "ERR Invalid command: \"" + command + "\"");
        }
        return;
      }
      if (typeof args === 'function') {
        callback = args;
        args = [];
      }
      if (!this.instance) {
        err = 'ERR No connection';
        if (callback) {
          callback(err);
        }
        return;
      }
      if (_.isString(args) || _.isNumber(args)) {
        args = [args];
      }
      if (!args) {
        args = [];
      }
      command = command.toUpperCase();
      if (!(command && command in available_commands)) {
        if (callback) {
          callback(err = "ERR Invalid command: \"" + command + "\"");
        }
        return;
      }
      send_command = function() {
        return _this.instance.send_command(command.toLowerCase(), args, function(err, reply) {
          var del_cmd_name, edit_cmd_name, key, replies, reply_type, scores, value, values;
          if (err) {
            if (callback) {
              callback(err.message);
            }
            return;
          }
          if (reply == null) {
            err = new Error('ERR Empty reply');
            if (callback) {
              callback(err.message);
            }
            return;
          }
          reply_type = reply_types[command];
          if (command === 'INFO') {
            replies = reply.split(/\r\n/g);
            if (callback) {
              callback(null, replies.length);
            }
            _this.socket.emit('redis:reset:vals');
            _.each(replies, function(reply) {
              var field, raw, value, _ref2;
              _ref2 = reply.split(/:/), field = _ref2[0], raw = _ref2[1];
              value = {
                id: "INFO_" + field,
                field: field,
                value: formatValue(raw),
                key: 'INFO',
                type: reply_type,
                raw: raw
              };
              return _this.socket.emit('redis:val', value);
            });
            return;
          }
          if (command === 'KEYS') {
            _this.socket.emit('redis:reset:keys');
            _this.last_keys_pattern = args[0] || '*';
          } else if (command === 'SELECT') {
            _this.instance.selected_db = args[0] || 0;
            _this.check_db_size(_this.refresh_keys);
          }
          switch (reply_type) {
            case 'status':
              if (callback) {
                callback(null, reply);
              }
              _this.socket.emit('redis:status', reply, command, args);
              return;
            case 'integer':
              if (callback) {
                callback(null, reply);
              }
              _this.socket.emit('redis:status', reply, command, args);
              return;
            case 'key':
              if (callback) {
                callback(null, reply.length);
              }
              _.each(reply, function(key) {
                return handleKey(_this.instance, key, function(err, key) {
                  return _this.socket.emit('redis:key', key);
                });
              });
              return;
          }
          if (callback) {
            if (reply_type === 'hash') {
              callback(null, _.size(reply));
            } else {
              callback(null, reply.length || 0);
            }
          }
          _this.socket.emit('redis:reset:vals');
          key = args[0];
          if (reply_type === 'bulk') {
            reply_type = 'string';
          }
          if (reply_type === 'zset' && __indexOf.call(args, 'WITHSCORES') >= 0) {
            values = [];
            scores = [];
            _.each(reply, function(value, i) {
              if (i % 2 === 0) {
                return values.push(value);
              } else {
                return scores.push(value);
              }
            });
            return _.each(values, function(raw, i) {
              var del_cmd_name, value;
              value = {
                id: "" + key + "_" + i,
                field: scores[i],
                value: formatValue(raw),
                key: key,
                type: reply_type,
                raw: raw
              };
              value['del_cmd_name'] = del_cmd_name = del_commands[reply_type];
              value['del_cmd_str'] = "" + del_cmd_name + " " + key + " " + raw;
              value['del_cmd_args'] = [key, raw];
              return _this.socket.emit('redis:val', value);
            });
          } else if (reply_type === 'hash' || reply_type === 'list' || reply_type === 'set' || reply_type === 'zset') {
            return _.each(reply, function(raw, field) {
              var del_cmd_name, edit_cmd_name, value;
              value = {
                id: "" + key + "_" + field,
                field: field,
                value: formatValue(raw),
                key: key,
                type: reply_type,
                raw: raw
              };
              if (reply_type === 'hash' || reply_type === 'list') {
                value['edit_cmd_name'] = edit_cmd_name = edit_commands[reply_type];
                value['edit_cmd_str'] = "" + edit_cmd_name + " " + key + " " + field + " &quot;...&quot;";
                value['edit_cmd_args'] = [key, field];
                value['del_cmd_name'] = del_cmd_name = del_commands[reply_type];
                value['del_cmd_str'] = "" + del_cmd_name + " " + key + " " + field;
                value['del_cmd_args'] = [key, field];
              }
              if (reply_type === 'set' || reply_type === 'zset') {
                value['del_cmd_name'] = del_cmd_name = del_commands[reply_type];
                value['del_cmd_str'] = "" + del_cmd_name + " " + key + " " + raw;
                value['del_cmd_args'] = [key, raw];
              }
              return _this.socket.emit('redis:val', value);
            });
          } else {
            value = {
              id: "" + key + "_",
              value: formatValue(reply),
              key: key,
              type: reply_type,
              raw: reply
            };
            value['edit_cmd_name'] = edit_cmd_name = edit_commands[reply_type];
            value['edit_cmd_str'] = "" + edit_cmd_name + " " + key + " &quot;...&quot;";
            value['edit_cmd_args'] = [key];
            value['del_cmd_name'] = del_cmd_name = del_commands[reply_type];
            value['del_cmd_str'] = "" + del_cmd_name + " " + key;
            value['del_cmd_args'] = [key];
            return _this.socket.emit('redis:val', value);
          }
        });
      };
      if (command in check_commands) {
        return this.check_key_size(key = args[0], send_command);
      } else {
        return send_command();
      }
    }, command_rate_limit);

    Client.prototype.end = function(reason) {
      this.monitor_events_queue = [];
      endClient(this.instance, this.connection);
      endClient(this.monitor, this.connection);
      this.instance = this.monitor = null;
      if (reason) {
        return this.socket.emit('error', reason);
      }
    };

    Client.prototype.check_db_size = function(callback) {
      var _this = this;
      return this.instance.dbsize(function(err, keys_count) {
        if (err || keys_count > keys_limit) {
          return _this.end("DB too large: " + keys_count + " keys over the " + keys_limit + " keys limit");
        } else if (callback) {
          return callback();
        }
      });
    };

    Client.prototype.check_key_size = function(key, callback) {
      var args, callback_wrapper,
        _this = this;
      args = [key];
      callback_wrapper = function(err, vals_count) {
        if (err || vals_count > vals_limit) {
          return _this.socket.emit('error', "Key too large: " + vals_count + " values (over the " + vals_limit + " values limit)");
        } else if (callback) {
          return callback();
        }
      };
      return this.instance.type(key, function(err, type) {
        switch (type) {
          case 'list':
            return _this.instance.llen(key, callback_wrapper);
          case 'set':
            return _this.instance.scard(key, callback_wrapper);
          case 'zset':
            return _this.instance.zcard(key, callback_wrapper);
          case 'hash':
            return _this.instance.hlen(key, callback_wrapper);
          default:
            return callback_wrapper(null, 0);
        }
      });
    };

    Client.prototype.handle_connect = _.throttle(function(connection, callback) {
      var handle_auth, password,
        _this = this;
      this.connection = connection;
      password = connection.password;
      this.end();
      try {
        this.instance = createClient(connection);
        this.monitor = createClient(connection, true);
      } catch (err) {
        if (err) {
          this.socket.emit('error', err.message);
          callback(null, false);
        }
        return;
      }
      this.instance.on('error', function(err) {
        if (!err) {
          return;
        }
        return _this.socket.emit('error', err.message);
      });
      this.monitor.on('error', function(err) {});
      if (password) {
        handle_auth = _.once(function(err) {
          if (!err) {
            return;
          }
          return _this.socket.emit('error', err);
        });
        this.instance.auth(password, handle_auth);
        this.monitor.auth(password, handle_auth);
      }
      this.monitor.monitor();
      this.monitor.on('monitor', this.handle_monitor);
      this.instance.on('ready', function() {
        _this.socket.emit('redis:ready');
        return _this.check_db_size(function() {
          return callback(null, true);
        });
      });
      return this.instance.on('end', function() {
        return _this.socket.emit('redis:end');
      });
    }, connection_rate_limit);

    Client.prototype.handle_disconnect = function(callback) {
      this.end();
      if (callback) {
        return callback(null, false);
      }
    };

    Client.prototype.refresh_keys = function() {
      this.socket.emit('redis:reset:keys');
      this.socket.emit('redis:reset:vals');
      return this.send_command('KEYS', this.last_keys_pattern);
    };

    Client.prototype.handle_monitor_event = function(args) {
      var command, key, val,
        _this = this;
      command = args.shift().toUpperCase();
      if (command in modify_val_commands) {
        console.log(command, key = args.shift(), val = args.shift());
      }
      if (command in modify_key_commands) {
        if (command === 'FLUSHDB' || command === 'FLUSHALL') {
          this.check_db_size(this.refresh_keys);
          return;
        }
        return this.instance.exists(key = args.shift(), function(err, does_exist) {
          if (!does_exist) {
            _this.socket.emit('redis:key:remove', {
              id: key
            });
            return;
          }
          return handleKey(_this.instance, key, function(err, key) {
            return _this.socket.emit('redis:key', key);
          });
        });
      }
    };

    Client.prototype.handle_monitor_events = _.debounce(function() {
      if (this.monitor_events_queue.length > monitor_queue_limit) {
        this.end("MONITOR too active: received " + monitor_queue_limit + " events over " + monitor_rate_limit + "ms");
        return;
      }
      _.each(this.monitor_events_queue, this.handle_monitor_event);
      return this.monitor_events_queue = [];
    }, monitor_rate_limit);

    Client.prototype.handle_monitor = function(time, args) {
      this.monitor_events_queue.push(args);
      return this.handle_monitor_events();
    };

    return Client;

  })();

}).call(this);
